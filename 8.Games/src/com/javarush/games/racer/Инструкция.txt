Игра Racer (1/28)
Предлагаем тебе написать увлекательную игру Racer. Начнем с правил.

Цель игры — достигнуть финиша, управляя гоночной машиной на оживленной трассе.
Количество очков зависит от длительности гонки: чем раньше игрок финиширует, тем больше очков он получит.
Игра окончена, когда игрок сталкивается с другой машиной или препятствием.
Создадим главный класс игры RacerGame. Чтобы использовать функциональность игрового движка, унаследуем его от класса Game, который содержит в себе методы для реализации игры.

Для начала нам нужно игровое поле (64х64), на которое будут добавляться игровые объекты. Так как значения высоты и ширины поля будут часто использоваться при реализации логики игры, есть смысл создать константы WIDTH и HEIGHT.

Перед запуском игры выполняется метод initialize(), задачей которого является установка начального состояния игры. Его нужно переопределить в классе RacerGame.

В методе initialize() необходимо:

задать размер игрового поля, вызвав setScreenSize(WIDTH, HEIGHT);
убрать отображение сетки, вызвав showGrid(false).
Чтобы успешно справиться с задачей Racer, рекомендуем прочесть статью про раздел "Игры". В ней ты найдешь информацию, которая будет полезна при написании игр.


Требования:
1. Должен существовать публичный класс RacerGame.
2. Класс RacerGame должен быть наследником класса Game.
3. В классе RacerGame должно существовать публичное статическое final int поле WIDTH, проинициализированное при объявлении значением 64.
4. В классе RacerGame должно существовать публичное статическое final int поле HEIGHT, проинициализированное при объявлении значением 64.
5. В классе RacerGame должен быть переопределен метод initialize() родительского класса Game.
6. В методе initialize() должен быть вызван метод showGrid(boolean) класса Game c параметром false.
7. В методе initialize() должен быть вызван метод setScreenSize(int, int) класса Game c параметрами WIDTH и HEIGHT.
8. В классе RacerGame должен быть импорт всего содержимого пакета com.javarush.engine.cell.



Игра Racer (2/28)
Теперь подготовим игровое поле.
В этой части создадим переменные и методы, с помощью которых в будущем отрисуем дорогу и дорожную разметку. По центру дороги будет расположена разделительная полоса.
Значение ее координаты по оси x равно половине ширины игрового поля и хранится в переменной CENTER_X.
По бокам будет расположена обочина. Ее ширина равна 14 и хранится в переменной ROADSIDE_WIDTH.

Создадим вспомогательные методы:

createGame() - для старта новой игры;
drawScene() - для отрисовки всех игровых объектов;
drawField() - для отрисовки фона игрового поля.


Требования:
1. В классе RacerGame должно существовать публичное статическое final int поле CENTER_X, проинициализированное при объявлении значением WIDTH / 2.
2. В классе RacerGame должно существовать публичное статическое final int поле ROADSIDE_WIDTH, проинициализированное при объявлении значением 14.
3. В классе RacerGame должен существовать приватный метод void createGame().
4. В классе RacerGame должен существовать приватный метод void drawScene().
5. В методе createGame() должен быть вызван метод drawScene().
6. В методе initialize() должен быть вызван метод createGame().
7. В методе initialize() вызов метода createGame() должен быть после вызова метода setScreenSize(int, int).
8. В классе RacerGame должен существовать приватный метод void drawField().
9. В методе drawScene() должен быть вызван метод drawField().



Игра Racer (3/28)
Приступим к отрисовке трассы в методе drawField().
Для установки цвета определенной ячейке используется метод setCellColor(int, int, Color). В качестве аргументов передаются координаты x, y и цвет.

Раскраска всего игрового поля делается в цикле.

В результате должна получится примерно такая трасса:



P.S.: Цвета можешь выбрать на свое усмотрение.


Требования:
1. В методе drawField() для ячеек игрового поля, у которых x равен CENTER_X, необходимо вызвать метод setCellColor(int, int, Color) с параметрами: CENTER_X, y, и любой цвет (например, Color.WHITE).
2. В методе drawField() для остальных ячеек игрового поля, у которых x больше либо равно ROADSIDE_WIDTH и x меньше (WIDTH - ROADSIDE_WIDTH), необходимо вызвать метод setCellColor(int, int, Color) с параметрами: координаты x и y, и любой цвет (например, Color.DIMGREY).
3. В методе drawField() для всех остальных ячеек игрового поля, необходимо вызвать метод setCellColor(int, int, Color) с параметрами: координаты x и y, и цвет, и любой цвет (например, Color.GREEN).
4. После вызова метода initialize() поле должно быть раскрашено в 3 разных цвета согласно условию.



Игра Racer (4/28)
В процессе игры появятся много объектов, которые будут двигаться по игровому полю и иногда его покидать. В случае вызова метода setCellColor(int, int, Color) с координатами, лежащими за пределами игрового поля, будет выбрасываться исключение.
Чтобы этого не произошло, переопредели его таким образом, чтобы вызов родительского метода происходил только с координатами, лежащими на игровом поле.

Подсказка: для вызова родительского метода используй ключевое слово super.


Требования:
1. В классе RacerGame должен быть переопределен метод setCellColor(int, int, Color) родительского класса Game.
2. В методе setCellColor(int, int, Color), если параметр метода x находится за пределами поля, метод не должен ничего делать.
3. В методе setCellColor(int, int, Color), если параметр метода y находится за пределами поля, метод не должен ничего делать.
4. В методе setCellColor(int, int, Color) должен вызываться метод базового класса, используя ключевое слово super.



Игра Racer (5/28)
Для представления игровых объектов создай класс GameObject. У всех игровых объектов будут общие черты:

- координаты (int x, int y) — координаты верхнего левого угла объекта на игровом поле;
- матрица отображения игрового объекта (int[][] matrix). Значения матрицы — порядковые номера цветов в Color.

Чтобы получить цвет, нужно использовать Color.values()[matrix[i][j]], где:

i — координата y в матрице matrix,
j — координата x в матрице matrix.
высота и ширина (int height, int width). Высота и ширина соответствуют размерам матрицы.
Также у объекта должен существовать метод, который его рисует.


Требования:
1. В отдельном файле должен существовать публичный класс GameObject.
2. В классе GameObject должно существовать публичное поле x типа int.
3. В классе GameObject должно существовать публичное поле y типа int.
4. В классе GameObject должно существовать публичное поле matrix типа int[][].
5. В классе GameObject должно существовать публичное поле width типа int.
6. В классе GameObject должно существовать публичное поле height типа int.
7. В классе GameObject должен существовать публичный конструктор с тремя параметрами: int, int, int[][], который устанавливает соответствующие значения полям x, y и полю matrix.
8. В конструкторе класса GameObject поле width должно инициализироваться значением matrix[0].length, где matrix — последний параметр конструктора.
9. В конструкторе класса GameObject поле height должно инициализироваться значением matrix.length, где matrix — последний параметр конструктора.
10. В классе GameObject должен существовать публичный метод void draw(Game).
11. В методе draw(Game) для каждой ячейки матрицы matrix должен быть вызван метод setCellColor(int, int, Color) у объекта типа Game. В качестве параметров необходимо передать: x класса + x в матрице, y класса + y в матрице, цвет.
12. В классе GameObject должен быть импорт всего содержимого пакета com.javarush.engine.cell.




Игра Racer (6/28)
Дорожное полотно, обочина и сплошная разделительная полоса — статические объекты: они не будут двигаться. Добавим еще две прерывистые полосы, которые будут создавать эффект движения.
Для этого у нас появилось несколько новых классов. Класс ShapeMatrix содержит матрицу элемента прерывистой полосы, а RoadMarking будет отвечать за ее отрисовку и движение.
Числа в матрице означают порядковый номер цвета в enum Color.

Добавь в RacerGame поле типа RoadMarking, инициализируй его в методе createGame() и отрисуй в методе drawScene().

Отрисовка прерывистой полосы должна происходить после отрисовки (поверх) статических объектов.


Требования:
1. В классе RacerGame должно существовать приватное поле roadMarking типа RoadMarking.
2. Поле roadMarking должно быть проинициализировано в методе createGame() новым объектом типа RoadMarking до вызова метода drawScene().
3. В методе drawScene() у объекта roadMarking должен быть вызван метод draw(Game). В качестве параметра метода используй this.
4. В методе drawScene() вызов метода roadMarking.draw(Game) должен быть после вызова метода drawField().




Игра Racer (7/28)
Сейчас займемся созданием машины игрока.

Для этого создадим класс PlayerCar и унаследуем его от GameObject.
Вначале машина игрока будет находиться в третьей по счету полосе движения и на одну позицию выше нижнего края игрового поля. Поэтому координата x будет равняться RacerGame.WIDTH/2 + 2, а y — RacerGame.HEIGHT - playerCarHeight - 1.

Матрица для машины уже есть в ShapeMatrix. Для обращения к машине игрока, экземпляр класса PlayerCar должен храниться в переменной player класса RacerGame. Чтобы увидеть машину на игровом поле, вызови у нее метод draw(Game).


Требования:
1. В отдельном файле должен существовать публичный класс PlayerCar.
2. Класс PlayerCar должен быть наследником класса GameObject.
3. В классе PlayerCar должно существовать приватное статическое поле playerCarHeight типа int, инициализированное при объявлении значением ShapeMatrix.PLAYER.length.
4. В классе PlayerCar должен существовать публичный конструктор без параметров, который вызывает конструктор базового класса с параметрами: RacerGame.WIDTH / 2 + 2, RacerGame.HEIGHT - playerCarHeight - 1, ShapeMatrix.PLAYER.
5. В классе RacerGame должно существовать приватное поле player типа PlayerCar.
6. Поле player должно быть проинициализировано в методе createGame() новым объектом типа PlayerCar до вызова метода drawScene().
7. В методе drawScene() у объекта player должен быть вызван метод draw(Game). В качестве параметра метода используй this.
8. В методе drawScene() метод draw(Game) у объекта player должен быть вызван после методов drawField() и roadMarking.draw(Game).



Игра Racer (8/28)
Прерывистые полосы должны двигаться, создавая эффект движения машины, а сама машина будет всегда находиться внизу игрового экрана.
Добавим машине поле, отвечающее за скорость. Его значение будет передаваться в roadMarking.move(int) и сообщать, насколько быстро нужно двигать разметку.
В RacerGame создадим метод moveAll(), который будет перемещать все подвижные игровые объекты (пока только разметку). moveAll() должен вызываться каждые 40 мс. Для этого в RacerGame нужно переопределить метод onTurn(int) и задать интервал в методе createGame().

Как работать с onTurn(int) — можешь прочить в описании движка.


Требования:
1. В классе PlayerCar должно существовать публичное поле speed типа int, инициализированное при объявлении значением 1.
2. В классе RacerGame должен существовать приватный метод void moveAll().
3. В методе moveAll() у объекта roadMarking должен быть вызван метод move(int). В качестве параметра передай в метод скорость игрока.
4. В классе RacerGame должен быть переопределен метод onTurn(int) родительского класса Game.
5. В методе onTurn(int) должен быть вызван метод moveAll().
6. В методе onTurn(int) должен быть вызван метод drawScene() после вызова метода moveAll().
7. В методе createGame() класса RacerGame должен быть вызван метод setTurnTimer(int) класса Game с параметром 40.



Игра Racer (9/28)
По горизонтали машина может двигаться вправо, влево или вообще не двигаться. Чтобы определять эти направления, создай enum Direction со значениями: RIGHT, LEFT, NONE.
У машины игрока должно быть поле, хранящее направление движения (Direction direction). Обращаться к нему будем через геттер и сеттер.

В классе PlayerCar создай метод move(), который в зависимости от направления движения будет менять координаты машины по горизонтали. Вызываться этот метод будет в moveAll().
Чтобы обрабатывать нажатие клавиш, переопредели метод onKeyPress(Key). В зависимости от нажатой клавиши, устанавливай соответствующее направление машине игрока, используя сеттер.


Требования:
1. В отдельном файле должен существовать публичный enum Direction со значениями: NONE, RIGHT, LEFT.
2. В классе PlayerCar должно существовать приватное поле direction типа Direction.
3. В классе PlayerCar должен существовать публичный сеттер void setDirection(Direction), который устанавливает значение полю direction.
4. В классе PlayerCar должен существовать публичный геттер Direction getDirection(), который возвращает значение поля direction.
5. В классе PlayerCar должен существовать публичный метод void move().
6. В методе move() класса PlayerCar, если значение поля direction равно Direction.LEFT, необходимо уменьшить координату x на единицу.
7. В методе move() класса PlayerCar, если значение поля direction равно Direction.RIGHT, необходимо увеличить координату x на единицу.
8. В методе moveAll() класса RacerGame у объекта player должен быть вызван метод move().
9. В классе RacerGame должен быть переопределен метод onKeyPress(Key) родительского класса Game.
10. Метод onKeyPress(Key) должен задавать игроку направление Direction.RIGHT, если параметр метода равен Key.RIGHT.
11. Метод onKeyPress(Key) должен задавать игроку направление Direction.LEFT, если параметр метода равен Key.LEFT.




Игра Racer (10/28)
На данный момент поведение машины не совсем соответствует ожидаемому:

- машина не перестает двигаться в сторону, когда кнопка направления отпущена;
- машина выезжает за границы дороги и игрового поля.

Чтобы это исправить, нужно реализовать поведение машины при отпускании клавиш RIGHT и LEFT.
Переопредели метод onKeyReleased(Key) и в нём устанавливай машине направление Direction.NONE, если это необходимо.
Для регулировки дорожного движения в пакете road создай класс RoadManager. В нём создай поля, которые будут хранить x-координаты границ проезжей части.
Используй их в методе move() класса PlayerCar, чтобы не допустить выезд машины за пределы дороги.
Если проверять границы дороги до изменения координаты x машины игрока, она сможет выезжать одним колесом на обочину. А если сначала изменить х, а потом проверить границы, машина игрока будет строго ограничена трассой.
Выбор за тобой.


Требования:
1. В классе RacerGame должен быть переопределен метод onKeyReleased(Key) родительского класса Game.
2. Метод onKeyReleased(Key) должен устанавливать игроку направление Direction.NONE, если параметр метода равен Key.RIGHT и направление движения игрока равно Direction.RIGHT.
3. Метод onKeyReleased(Key) должен устанавливать игроку направление Direction.NONE, если параметр метода равен Key.LEFT и направление движения игрока равное Direction.LEFT.
4. В пакете road в отдельном файле должен существовать публичный класс RoadManager.
5. В классе RoadManager должно существовать публичное статическое final int поле LEFT_BORDER, проинициализированное при объявлении значением RacerGame.ROADSIDE_WIDTH.
6. В классе RoadManager должно существовать публичное статическое final int поле RIGHT_BORDER, проинициализированное при объявлении значением RacerGame.WIDTH - LEFT_BORDER.
7. Метод move() класса PlayerCar должен устанавливать значение полю x, равное RoadManager.LEFT_BORDER, если x < RoadManager.LEFT_BORDER.
8. Метод move() класса PlayerCar должен устанавливать значение полю x, равное RoadManager.RIGHT_BORDER - width, если x > RoadManager.RIGHT_BORDER - width.




Игра Racer (11/28)
На пути игрока будут различные препятствия: другие машины, едущие навстречу, и шипы, неподвижные относительно трассы. Эти препятствия будут наследоваться от класса RoadObject, который ты можешь найти в пакете road.
Типы всех возможных препятствий перечислены в enum RoadObjectType. А класс ShapeMatrix пополнился новыми матрицами для отображения препятствий.
На этом этапе займемся шипами. Создай класс Thorn (шипы) и унаследуй его от RoadObject.
Для создания объектов-препятствий создай метод private RoadObject createRoadObject(RoadObjectType type, int x, int y), который в зависимости от полученных параметров будет создавать и возвращать новое препятствие.


Требования:
1. В классе GameObject должен существовать публичный конструктор с двумя параметрами: int x, int y, который устанавливает соответствующие значения полям x, y.
2. В пакете road в отдельном файле должен существовать публичный класс Thorn.
3. Класс Thorn должен быть наследником класса RoadObject.
4. В классе Thorn должен существовать публичный конструктор с двумя параметрами: int x, int y, который вызывает конструктор базового класса с параметрами: RoadObjectType.THORN, x, y.
5. В конструкторе класса Thorn поле speed (поле суперкласса) должно инициализироваться значением 0.
6. В классе RoadManager должен существовать приватный метод RoadObject createRoadObject(RoadObjectType type, int x, int y).
7. Метод createRoadObject(RoadObjectType, int, int) должен вернуть новый объект типа Thorn, если type равен RoadObjectType.THORN.
8. Метод createRoadObject(RoadObjectType, int, int) должен вернуть null, если type не равен RoadObjectType.THORN.
9. В методе createRoadObject(RoadObjectType, int, int) конструктор класса Thorn должен быть вызван с параметрами x, y (соответствующие параметры метода).




Игра Racer (12/28)
Объекты-препятствия должны появляться в пределах проезжей части в случайной позиции.
В классе RoadManager введи две константы: FIRST_LANE_POSITION и FOURTH_LANE_POSITION — крайняя левая и крайняя правая позиции координат x матриц объектов-препятствий на проезжей части. Присвой им значения 16 и 44 соответственно.

Также в классе RoadManager должен существовать список всех текущих объектов-препятствий.
В этом же классе создай метод addRoadObject(RoadObjectType, Game), который будет генерировать позицию нового препятствия и добавлять его в список всех объектов-препятствий. Координаты препятствия должны генерироваться следующим образом:

x = game.getRandomNumber(FIRST_LANE_POSITION, FOURTH_LANE_POSITION) — случайное число в пределах проезжей части;
y = -1 * RoadObject.getHeight(type) — изначально объект располагается за пределами игрового поля, чтобы появиться плавно.


Требования:
1. В классе RoadManager должно существовать приватное статическое final int поле FIRST_LANE_POSITION, проинициализированное при объявлении значением 16.
2. В классе RoadManager должно существовать приватное статическое final int поле FOURTH_LANE_POSITION, проинициализированное при объявлении значением 44.
3. В классе RoadManager должно существовать приватное поле items типа List<RoadObject>, инициализированное при объявлении значением нового ArrayList.
4. В классе RoadManager должен существовать приватный метод void addRoadObject(RoadObjectType type, Game game).
5. В методе addRoadObject(RoadObjectType, Game) должна создаваться локальная переменная int x и при создании инициализироваться значением game.getRandomNumber(FIRST_LANE_POSITION, FOURTH_LANE_POSITION).
6. В методе addRoadObject(RoadObjectType, Game) должна создаваться локальная переменная int y, и при создании инициализироваться значением -1 * RoadObject.getHeight(type).
7. В методе addRoadObject(RoadObjectType, Game) должен вызываться метод createRoadObject(RoadObjectType, int, int) с параметрами: type (параметр метода), x и y (локальные переменные метода).
8. В методе addRoadObject(RoadObjectType, Game) результат вызова метода createRoadObject(RoadObjectType, int, int) должен добавляться в список items, если он не равен null.
9. В классе RoadManager должен быть импорт класса com.javarush.engine.cell.Game.



Игра Racer (13/28)
Класс RoadManager носит такое название не просто так: он управляет всеми препятствиями на дороге.
Он должен уметь прорисовывать (draw) и передвигать (move) все хранимые объекты.

В классе RacerGame создай поле RoadManager roadManager, чтобы была возможность обращаться к нему.
Поле roadManager инициализируй в createGame(), а в drawScene() вызови у него draw(Game).


Требования:
1. В классе RoadManager должен существовать публичный метод void draw(Game).
2. В методе draw(Game) класса RoadManager у каждого объекта из списка items необходимо вызвать метод draw(Game).
3. В классе RoadManager должен существовать публичный метод void move(int boost).
4. В методе move(int) класса RoadManager у каждого объекта из списка items необходимо вызвать метод move. В качестве параметра передай сумму boost и скорости текущего объекта.
5. В классе RacerGame должно существовать приватное поле roadManager типа RoadManager.
6. Поле roadManager должно быть проинициализировано в методе createGame() новым объектом типа RoadManager до вызова метода drawScene().
7. В методе drawScene() у объекта roadManager должен быть вызван метод draw(Game). В качестве параметра передай в метод this.
8. У объекта roadManager метод draw(Game) в методе drawScene() должен быть вызван после метода drawField().



Игра Racer (14/28)
Пришло время отображать шипы на экране.

На трассе должно быть не больше одного объекта Thorn одновременно.
Для проверки этого условия создай метод isThornExists() в классе RoadManager.
Чтобы проверить, является ли объект RoadObject шипами, можно использовать его поле type.
За генерацию шипов будет отвечать отдельный метод void generateThorn(Game).
Он будет проверять, есть ли на дороге шипы, и если их нет — генерировать новые с вероятностью 10%.
В будущем препятствиями будут не только шипы. Для генерации всех препятствий потребуется метод generateNewRoadObjects(Game), но пока он будет генерировать только шипы. Он должен вызываться в методе onTurn(int) класса RacerGame.

Также шипы должны передвигаться вместе с трассой в методе moveAll().


Требования:
1. В классе RoadManager должен существовать приватный метод boolean isThornExists().
2. Метод isThornExists() должен возвращать true, если в списке items есть шипы. Иначе — false.
3. В классе RoadManager должен существовать приватный метод void generateThorn(Game).
4. У объекта game в методе generateThorn(Game game) нужно вызвать метод getRandomNumber(int) с параметром 100.
5. В методе generateThorn(Game game), если метод getRandomNumber(int) вернул меньше 10 и в списке items шипов нет, необходимо вызвать метод addRoadObject(RoadObjectType, Game) с параметрами: RoadObjectType.THORN, game.
6. В классе RoadManager должен существовать публичный метод void generateNewRoadObjects(Game).
7. В методе generateNewRoadObjects(Game) необходимо вызвать метод generateThorn(Game).
8. В методе onTurn(int) класса RacerGame у объекта roadManager необходимо вызвать метод generateNewRoadObjects(Game). В качестве параметра передай в метод «this».
9. В методе onTurn(int) класса RacerGame метод generateNewRoadObjects(Game) объекта roadManager должен вызываться до drawScene().
10. В методе moveAll() класса RacerGame у объекта roadManager должен быть вызван метод move(int). В качестве параметра передай в метод скорость игрока.




Игра Racer (15/28)
Сейчас шипы появляются только один раз (в начале игры). Чтобы генерировались новые шипы, старые нужно удалять из списка items после того, как они вышли за пределы экрана. Для удаления можно либо использовать итератор, либо создать копию списка items и проходить по ней циклом, и если объект нужно удалить из списка — вызывать items.remove(item).


Требования:
1. В классе RoadManager должен существовать приватный метод void deletePassedItems().
2. В методе deletePassedItems() из списка items должны удалятся элементы, у которых координата y больше либо равна RacerGame.HEIGHT.
3. Метод deletePassedItems() не должен изменять ссылку, которая содержится в поле items.
4. Метод move(int) класса RoadManager должен вызывать метод deletePassedItems().
5. В методе move(int) класса RoadManager метод deletePassedItems() должен вызываться после движения всех объектов из списка items.




Игра Racer (16/28)
На данный момент при пересечении с препятствием машина игрока продолжает движение. В этой части реализуем метод, который будет проверять, столкнулась ли машина с преградой.
При реализации этого метода используй метод isCollision(GameObject) класса GameObject, который мы реализовали вместо тебя. Разберись как он работает.

Столкновение должно быть визуально заметно, то есть необходимо изменить изображение машины игрока.
Для этого в класс PlayerCar добавь метод stop(), который будет устанавливать полю matrix значение ShapeMatrix.PLAYER_DEAD.


Требования:
1. В классе RoadManager должен существовать публичный метод boolean checkCrush(PlayerCar).
2. Метод checkCrush(PlayerCar) должен вызывать метод isCollision(GameObject) класса GameObject у элементов списка items для проверки пересечений.
3. Метод checkCrush(PlayerCar) должен возвращать true, если игрок имеет пересечение с любым из объектов списка items.
4. Метод checkCrush(PlayerCar) должен возвращать false, если игрок не пересекается со всеми объектами из списка items.
5. В классе PlayerCar должен существовать публичный метод void stop().
6. В методе stop() матрица игрока должна заменяться на ShapeMatrix.PLAYER_DEAD.



Игра Racer (17/28)
Игра должна останавливаться в двух случаях: когда игрок выиграл или проиграл. Пока реализуем остановку только для проигрышей.
Для хранения текущего состояния игры создадим поле boolean isGameStopped, начальное состояние которого должно быть false.

Когда игрок сталкивается с препятствием — он проиграл, а значит игра должна остановиться, а на экран — вывестись сообщение, например, GAME OVER.
Все действия, которые осуществляются при проигрыше, удобно вынести в отдельный метод gameOver().
В методе onTurn(int) нужно проверять пересечение игрока с препятствиями (метод checkCrush(PlayerCar)).


Требования:
1. В классе RacerGame должно существовать приватное поле isGameStopped типа boolean.
2. Поле isGameStopped должно быть проинициализировано значением false в методе createGame().
3. В классе RacerGame должен существовать приватный метод void gameOver().
4. В методе gameOver() необходимо установить полю isGameStopped значение true.
5. В методе gameOver() должен вызываться метод showMessageDialog(Color, String, Color, int).
6. В методе gameOver() должен вызываться метод stopTurnTimer().
7. В методе gameOver() у объекта player должен вызываться метод stop().
8. В методе onTurn(int) класса RacerGame у объекта roadManager необходимо вызвать метод checkCrush(PlayerCar) до вызова метода moveAll().
9. В методе onTurn(int) класса RacerGame, если метод checkCrush(PlayerCar) вернул true, необходимо вызвать метод gameOver().
10. В методе onTurn(int) класса RacerGame, если метод checkCrush(PlayerCar) вернул true, необходимо вызвать метод drawScene() после метода gameOver() и больше ничего не делать.



Игра Racer (18/28)
После завершения игры должна быть возможность начать заново. Реализуй перезапуск игры по нажатию клавиши SPACE.
Чтобы игрок мог быстрее преодолеть трассу, его машина должна иметь возможность увеличивать скорость.
Реализуй увеличение скорости в 2 раза по нажатию клавиши UP, а при отпускании этой клавиши — возвращение к начальной скорости.


Требования:
1. Если параметр метода — клавиша SPACE и игра была остановлена (isGameStopped == true), метод onKeyPress(Key) класса RacerGame должен вызывать метод createGame().
2. В классе PlayerCar должен существовать публичный сеттер, который устанавливает значение поля speed, равное полученному параметру метода.
3. Метод onKeyPress(Key) должен устанавливать игроку скорость равную 2, если параметр метода равен Key.UP.
4. Метод onKeyReleased(Key) класса RacerGame должен устанавливать игроку скорость, равную 1, если параметр метода равен Key.UP.



Игра Racer (19/28)
Кроме шипов, на трассе неплохо бы смотрелись машины разных типов.
Для представления машин на игровом поле создай в пакете road общий для всех типов машин класс Car и унаследуй его от RoadObject.
Все машины будут двигаться со скоростью 1.

Так как метод reateRoadObject(RoadObjectType, int, int) класса RoadManager отвечает за создание всех дорожных объектов, вместо null он должен возвращать новый объект типа Car.
Для генерации новых машин создай метод generateRegularCar(Game game) в классе RoadManager.
Чтобы трасса не была слишком загружена, новая машина должна создаваться с вероятностью 30%.
Тип машины должен быть случайно выбран из первых четырех элементов RoadObjectType.
Не забудь каждую созданную машину добавить в список items.


Требования:
1. В пакете road должен существовать публичный класс Car.
2. Класс Car должен быть наследником класса RoadObject.
3. В классе Car должен существовать публичный конструктор с тремя параметрами: RoadObjectType type, int x, int y, который вызывает конструктор базового класса с параметрами: type, x, y.
4. В конструкторе класса Car поле speed (поле суперкласса) должно инициализироваться значением 1.
5. Метод createRoadObject(RoadObjectType, int, int) класса RoadManager должен вернуть новый объект типа Car, если type не равен RoadObjectType.THORN.
6. В методе createRoadObject(RoadObjectType, int, int) конструктор класса Car должен быть вызван с параметрами: type, x, y (соответствующие параметры метода).
7. В классе RoadManager должен существовать приватный метод void generateRegularCar(Game).
8. В методе generateRegularCar(Game game) необходимо у объекта game вызвать метод getRandomNumber(int) с параметром 100.
9. В методе generateRegularCar(Game game) класса RoadManager должна создаваться локальная переменная int carTypeNumber, проинициализированная значением game.getRandomNumber(4).
10. В методе generateRegularCar(Game game), если метод getRandomNumber(100) вернул меньше 30, необходимо вызвать метод addRoadObject(RoadObjectType, Game) с параметрами: RoadObjectType.values()[carTypeNumber], game.
11. В методе generateNewRoadObjects(Game) класса RoadManager необходимо вызвать метод generateRegularCar(Game).



Игра Racer (20/28)
Сейчас встречных машин слишком много. Чтобы игру можно было пройти, промежутки между препятствиями должны быть достаточно большими.
С другой стороны, если они будут слишком большие, игра станет очень простой и не такой интересной.
Оптимальным расстоянием будет 12: оно соответствует габаритам машины игрока с небольшим запасом.
Это значение будем хранить в константе PLAYER_CAR_DISTANCE.

Реализуй метод boolean isRoadSpaceFree(RoadObject object), который будет проверять, есть ли достаточно свободного места на дороге для размещения новой машины.
В этом тебе поможет метод isCollisionWithDistance(GameObject, int). Этот метод возвращает false, если расстояние между объектами по горизонтали и вертикали больше переданной дистанции.
Если на дороге есть свободное место, добавляй новую машину в items.


Требования:
1. В классе RoadManager должно существовать приватное статическое final int поле PLAYER_CAR_DISTANCE, проинициализированное при объявлении значением 12.
2. В классе RoadManager должен существовать приватный метод boolean isRoadSpaceFree(RoadObject object).
3. Метод isRoadSpaceFree(RoadObject object) должен вызывать метод isCollisionWithDistance(GameObject, int) у элементов списка items для проверки пересечений объектов. В качестве параметров передавать: object, PLAYER_CAR_DISTANCE.
4. Метод isRoadSpaceFree(RoadObject) должен возвращать false, если метод isCollisionWithDistance(GameObject, int) с любым из объектов списка items вернул true.
5. Метод isRoadSpaceFree(RoadObject) должен возвращать true, если метод isCollisionWithDistance(GameObject, int) со всеми объектами из списка items вернул false.
6. Метод addRoadObject(RoadObjectType, Game) должен вызывать метод isRoadSpaceFree(RoadObject).
7. Метод addRoadObject(RoadObjectType, Game) должен добавлять созданный методом createRoadObject(RoadObjectType, int, int) объект в список items только в том случае, если метод isRoadSpaceFree(RoadObject) вернул true.



Игра Racer (21/28)
Давай немного усложним игру. Добавим машину с "пьяным" водителем.
Для ее представления на игровом поле в пакет road был добавлен новый класс MovingCar. Используй его для создания таких машин.
В отличие от обычных машин, "пьяный" водитель будет двигаться и по горизонтали.
Чтобы он не пересекался с другими машинами, в методе move() класса MovingCar, происходит проверка таких пересечений.
Для этого в метод move(int boost), кроме скорости, нужно еще передавать список всех объектов-препятствий.

Еще одна тонкость заключается в том, что MovingCar — наследник класса RoadObject, и переопределяет его метод move, поэтому необходимо добавить второй аргумент и методу move в родительском классе.

При большом количестве "пьяных" водителей на трассе игра станет слишком сложной, поэтому позаботься о том, чтобы на трассе одновременно была только одна такая машина.
Для проверки этого реализуй метод isMovingCarExists() по аналогии с методом isThornExists().

За генерацию MovingCar будет отвечать отдельный метод void generateMovingCar(Game).
Его реализация аналогична реализации метода generateThorn(Game).


Требования:
1. В классе RoadObject метод void move() должен принимать два параметра: скорость движения и список RoadObject-ов.
2. В классе RoadManager в методе void move(int boost) у объектов типа RoadObject должен вызываться метод move() с двумя параметрами: первый — сумма boost и скорости текущего объекта, второй — список items.
3. Метод createRoadObject(RoadObjectType, int, int) класса RoadManager должен вернуть новый объект типа MovingCar, если type равен RoadObjectType.DRUNK_CAR.
4. В классе RoadManager должен существовать приватный метод boolean isMovingCarExists().
5. Метод isMovingCarExists() должен возвращать true, если в списке items есть объект типа MovingCar. Иначе — false.
6. В классе RoadManager должен существовать приватный метод void generateMovingCar(Game).
7. В методе generateMovingCar(Game game) у объекта game необходимо вызвать метод getRandomNumber(int) с параметром 100.
8. В методе generateMovingCar(Game game), если метод getRandomNumber(int) вернул меньше 10 и метод isMovingCarExists() вернул false, необходимо вызвать метод addRoadObject(RoadObjectType, Game) с параметрами: RoadObjectType.DRUNK_CAR, game.
9. В методе generateNewRoadObjects(Game) класса RoadManager необходимо вызвать метод generateMovingCar(Game).



Игра Racer (22/28)
Приступим к созданию финишной линии. Матрица для нее уже есть в ShapeMatrix. Финишная линия появится на трассе в конце игры.
На самом деле объект финишной линии создается в начале игры, но находится выше игрового поля, поэтому невидим.
Как только флаг, ответственный за отображение FinishLine, получит значение true, финишная линия начнет движение вниз и появится на игровом поле.


Требования:
1. В отдельном файле должен существовать публичный класс FinishLine.
2. Класс FinishLine должен быть наследником класса GameObject.
3. В классе FinishLine должен существовать публичный конструктор без параметров, который вызывает конструктор базового класса с параметрами: RacerGame.ROADSIDE_WIDTH, -1 * ShapeMatrix.FINISH_LINE.length, ShapeMatrix.FINISH_LINE.
4. В классе FinishLine должно существовать приватное поле isVisible типа boolean, проинициализированное при объявлении значением false.
5. В классе FinishLine должен существовать публичный метод void show().
6. Метод show() должен устанавливать значение полю isVisible, равное true.
7. В классе FinishLine должен существовать публичный метод void move(int boost).
8. Метод move(int) не должен ничего делать, если финишная линия не видна (isVisible равно false).
9. Метод move(int boost) должен увеличивать координату y финишной линии на значение boost.



Игра Racer (23/28)
В этой части реализуем прорисовку и движение финишной линии. Для этого ее экземпляр должен храниться в основном классе игры и пересоздаваться при старте новой игры.
Методы draw(Game) и move(int) экземпляра класса FinishLine, как и у всех объектов, будут вызываться каждые 40мс, но результат их вызова будет игнорироваться до вызова метода show().
Также давай определимся с условиями победы. Чтобы прохождение игры было достаточно сложным и интересным, победа должна наступать после преодоления 40 машин-препятствий.
Будем хранить это значение в константе RACE_GOAL_CARS_COUNT.


Требования:
1. В классе RacerGame должно существовать приватное поле finishLine типа FinishLine.
2. Поле finishLine должно быть проинициализировано в методе createGame() новым объектом типа FinishLine до вызова метода drawScene().
3. В методе drawScene() у объекта finishLine должен быть вызван метод draw(Game). В качестве параметра передай в метод this.
4. В методе drawScene() метод draw(Game) у объекта finishLine должен быть вызван после метода drawField().
5. В методе moveAll() у объекта finishLine должен быть вызван метод move(int). В качестве параметра передай в метод скорость игрока.
6. В классе RacerGame должно существовать приватное статическое final int поле RACE_GOAL_CARS_COUNT, проинициализированное при объявлении значением 40.



Игра Racer (24/28)
Чтобы проверять выполнение условий победы, нам нужно будет знать реальное количество машин, с которыми разминулся игрок.
Для этого создай поле passedCarsCount в классе RoadManager и геттер к нему.
Значение этого поля должно увеличиваться на единицу после прохождения каждой машины-препятствия (удаления машины из списка items).

Сравнивать passedCarsCount и RACE_GOAL_CARS_COUNT будем в методе onTurn(int).
Если значение passedCarsCount больше или равно RACE_GOAL_CARS_COUNT, значит цель достигнута и нужно показать финишную линию.


Требования:
1. В классе RoadManager должно существовать приватное поле passedCarsCount типа int, инициализированное при объявлении значением 0.
2. В классе RoadManager должен существовать публичный геттер int getPassedCarsCount(), который возвращает значение поля passedCarsCount.
3. В методе deletePassedItems() класса RoadManager необходимо увеличивать значение поля passedCarsCount на единицу, если из списка items удаляется объект и тип этого объекта — не шипы.
4. В методе onTurn(int) класса RacerGame необходимо вызвать у объекта finishLine метод show(), если значение, которое вернул метод roadManager.getPassedCarsCount(), больше либо равно RACE_GOAL_CARS_COUNT.
5. В методе onTurn(int) класса RacerGame метод show() объекта finishLine должен вызываться до moveAll().




