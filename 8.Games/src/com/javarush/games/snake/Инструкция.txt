Игра змейка (1/20)


Чтобы успешно справиться с задачей, рекомендуем прочесть статью про раздел "Игры".
https://javarush.ru/groups/posts/2052-razdel-igrih-na-javarush-chastjh-1-populjarnihe-voprosih
В ней ты найдешь информацию, которая будет полезна при написании игр.


Давай напишем игру "Змейка".
Правила игры:
1.  Игрок управляет движением змейки, которая ползает по квадратному полю: вверх, вниз, вправо и влево.
Остановить движение змейки нельзя.
2.  Цель игры — съесть как можно большее количество яблок, которые появляются поочередно, в случайном месте
игрового поля, как только змейка "проглотит" предыдущее.
3.  С каждым новым яблоком змейка растет на один сегмент (занимает на одну ячейку больше). 3. В нашей игре
на старте змейка занимает три ячейки (имеет три сегмента) и может дорасти до 28.
4.  По мере того, как растет змейка, скорость игры увеличивается.
5.  Змейка не может проходить "сквозь себя" или выходить за пределы игрового поля.
5.  Игра оканчивается победой, если длина змейки увеличилась до 28 сегментов.
6.  Игра оканчивается проигрышем, если касается сама себя или края поля.
Теперь приступаем к реализации игры:
Нам понадобится класс, который будет содержать логику игры. Назовем его SnakeGame. Не забудь унаследовать
его от класса Game. Этот и другие классы "движка" находятся в пакете com.javarush.engine.cell,
и чтобы ими пользоваться, класс SnakeGame должен содержать такой импорт:
import com.javarush.engine.cell.*;
Если ты все сделал правильно, уже можно запустить SnakeGame и увидеть пустое игровое поле.
Создай переменные для хранения ширины и высоты игрового поля.
Переопредели метод родительского класса public void initialize(): он будет содержать команды, которые
выполнятся один раз при запуске игры. Например, установка размеров игрового поля.


Требования:
1.	Должен существовать публичный класс SnakeGame.
2.	Класс SnakeGame должен быть наследником класса Game.
3.	В классе SnakeGame должно существовать поле public static final int WIDTH, инициализированное при объявлении значением 15.
4.	В классе SnakeGame должно существовать поле public static final int HEIGHT, инициализированное при объявлении значением 15.
5.	В классе SnakeGame должен быть переопределен метод initialize() родительского класса Game.
6.	В методе initialize() должен быть вызван метод setScreenSize(int, int) класса Game c параметрами WIDTH и HEIGHT.
7.	В классе SnakeGame должен быть импорт всего содержимого пакета com.javarush.engine.cell.


Игра змейка (2/20)

Мы готовы создать игру. Чтобы выполнить это действие, будем использовать отдельный метод — createGame().
Он будет содержать команды, которые выполняются при запуске игры.
Чтобы отрисовать игровое поле, создай метод drawScene().

Метод initialize() будет вызывать createGame(). Метод createGame() будет вызывать drawScene(). А метод drawScene() пока будет раскрашивать игровой экран.


Требования:
1.	В классе SnakeGame должен существовать private void метод createGame().
2.	В классе SnakeGame должен существовать private void метод drawScene().
3.	В методе createGame() должен быть вызван метод drawScene().
4.	В методе initialize() должен быть вызван метод createGame().
5.	В методе initialize() метод createGame() вызывается после метода setScreenSize(int, int).
6.	В методе drawScene() для каждой ячейки игрового поля вызови метод setCellColor(int, int, Color) с параметрами: координаты x и y и любой цвет. Например, Color.DARKSEAGREEN).


Игра змейка (3/20)

Для хранения объектов игрового поля нам понадобится дополнительный класс.
Объект этого класса будет хранить координаты соответствующей ячейки.
Назовем его GameObject.


Требования:
1.	Должен существовать публичный класс GameObject.
2.	В классе GameObject должно существовать публичное поле x типа int.
3.	В классе GameObject должно существовать публичное поле y типа int.
4.	В классе GameObject должен существовать один конструктор с двумя параметрами типа int, который устанавливает соответствующие значения полям x и y.


Игра змейка (4/20)

Одним из игровых объектов будет яблоко. Создай для него класс Apple и унаследуй его от класса GameObject.

Чтобы отобразить яблоко на игровом поле, можно покрасить ячейку, содержащую яблоко, в какой-нибудь цвет. Или можно вывести в этой ячейке
какой-нибудь символ, похожий на яблоко. Пусть класс Apple хранит этот символ в переменной APPLE_SIGN.

В классе Apple добавь метод draw(Game): он будет отрисовывать яблоко на игровом поле. Для этого в методе draw(Game game) нужно
вызвать: game.setCellValueEx(…).

Чтобы посмотреть, как будет выглядеть яблоко, в методе createGame() создай новое с координатами (7, 7) и вызови у него метод draw(Game).


Требования:
1.	Должен существовать публичный класс Apple.
2.	Класс Apple должен быть наследником класса GameObject.
3.	В классе Apple должен существовать один конструктор с двумя параметрами типа int (x и y), который вызывает конструктор базового класса с параметрами x и y, используя ключевое слово super.
4.	В классе Apple должно существовать приватное статическое final поле String APPLE_SIGN, инициализированное при объявлении. Например, использовать можно UTF-16 символ яблока &quot;\uD83C\uDF4E&quot;.
5.	В классе Apple должен существовать публичный void метод draw(Game).
6.	В методе draw(Game) должен быть вызывать метод setCellValueEx(int, int, Color, String, Color, int) у объекта типа Game с параметрами: x, y, Color.NONE, APPLE_SIGN, &lt;цвет яблока&gt;, 75. (&lt;цвет яблока&gt; используй какой тебе нравится, например, Color.GREEN).
7.	В методе createGame() класса SnakeGame должно быть создано новое яблоко (экземпляр класса Apple) с координатами: 7, 7.
8.	У созданного яблока должен быть вызван метод draw(Game). В качестве параметра метода передай this.
9.	В классе Apple должен быть импорт всего содержимого пакета com.javarush.engine.cell.


Игра змейка (5/20)

Теперь займемся змейкой, а тестовое создание и отрисовку яблока в createGame() удалим.

Создай класс Snake. Змейка будет состоять из нескольких ячеек, т.е. из нескольких GameObject-ов. Кроме того,
их количество может изменяться: оно будет
увеличиваться при поедании яблок. Список всех сегментов змейки будем хранить в поле List<GameObject>
snakeParts.

В классе Snake добавь конструктор, который будет создавать сразу три сегмента змейки.


Требования:
1.	В методе createGame() класса SnakeGame не должно создаваться новое яблоко.
2.	Должен существовать публичный класс Snake.
3.	В классе Snake должен существовать один публичный конструктор с двумя параметрами типа int (x и y).
4.	В классе Snake должно быть создано приватное поле List&lt;GameObject&gt; snakeParts, инициализированное при объявлении новым списком типа ArrayList&lt;&gt;.
5.	В конструкторе должны быть созданы три объекта типа GameObject с параметрами: первый &ndash; (x, y); второй &ndash; (x + 1, y); третий &ndash; (x + 2, y).
6.	Созданные в конструкторе объекты типа GameObject должны быть добавлены в список snakeParts в порядке: первый, второй, третий.


Игра змейка (6/20)

Когда у нас уже есть змейка, нужно её отрисовать. Для этого, по аналогии с классом Apple, в классе Snake создай константы HEAD_SIGN и BODY_SIGN,
которые будут хранить символы для отрисовки головы и тела змейки. Также создай метод draw(Game), который должен отрисовывать змейку
на игровом поле.

Управлять отрисовкой змейки будем из класса SnakeGame. Поэтому создай переменную Snake snake в классе SnakeGame: в ней будет храниться
текущее состояние змейки. В методе createGame() создай новую змейку в центре игрового поля и присвой её переменной snake. В методе drawScene()
вызови у змейки метод draw(Game), чтобы отобразить её на игровом поле.


Требования:
1.	В классе Snake должно существовать приватное статическое final поле String HEAD_SIGN, инициализированное при объявлении. Например, использовать можно UTF-16 символ &quot;\uD83D\uDC7E&quot;.
2.	В классе Snake должно существовать приватное статическое final поле String BODY_SIGN, инициализированное при объявлении. Например, использовать можно UTF-8 символ &quot;\u26AB&quot;.
3.	В классе Snake должен существовать публичный void метод draw(Game game).
4.	В методе draw(Game) должен вызываться метод setCellValue(int, int, String) класса Game для каждого объекта GameObject из списка snakeParts.
5.	Метод setCellValue(int, int, String) для головы змеи (элемент с индексом 0 из списка snakeParts) должен вызываться с параметрами x и y головы, и HEAD_SIGN.
6.	Метод setCellValue(int, int, String) для каждого сегмента тела змеи (элементы с индексом не 0 из списка snakeParts) должен вызываться с параметрами x и y сегмента, и BODY_SIGN.
7.	В классе SnakeGame должно существовать приватное поле Snake snake.
8.	В методе createGame() класса SnakeGame должна быть создана новая змея (экземпляр класса Snake) с координатами: WIDTH / 2, HEIGHT / 2 перед вызовом метода drawScene().
9.	В методе createGame() полю snake необходимо присвоить ссылку на созданный объект типа Snake.
10.	В методе drawScene() последним должен быть вызван метод draw(Game) у объекта snake. В качестве параметра метода передай this.
11.	В классе Snake должен быть импорт всего содержимого пакета com.javarush.engine.cell.


Игра змейка (7/20)

Объект на игровом поле может иметь одно из двух состояний: он может быть или "жив" (isAlive=true), или нет (isAlive=false).
Например, если змейка ударяется о край игрового поля, она умирает. То же происходит с яблоком, когда его съедает змейка. Чтобы хранить состояние
объектов, создай в классах Apple и Snake переменную boolean isAlive. Измени отрисовку змейки таким образом, чтобы "неживая" змейка была красного цвета.

Змейка может двигаться в одном из четырех направлений. Чтобы указать направления, создай enum Direction со значениями UP, RIGHT, DOWN, LEFT,
а в классе Snake — поле direction, которое будет хранить текущее направление движения. Пусть изначально змейка двигается влево. Изменять
направление движения змейки будем методом setDirection(Direction). Создай его.


Требования:
1.	В классе Apple должно существовать публичное поле boolean isAlive, инициализированное значением true.
2.	В классе Snake должно существовать публичное поле boolean isAlive, инициализированное значением true.
3.	В методе draw(Game) класса Snake замени все вызовы метода setCellValue(int, int, String) на вызовы метода setCellValueEx(int, int, Color, String, Color, int) с параметрами: x, y, Color.NONE, HEAD_SIGN (или BODY_SIGN), &lt;цвет змейки&gt;, 75. Если змейка &quot;неживая&quot;, ее цвет должен быть Color.RED. Иначе &mdash; любой другой, например, Color.BLACK.
4.	Должен существовать публичный enum Direction со значениями: UP, RIGHT, DOWN, LEFT.
5.	В классе Snake должно существовать приватное поле Direction direction, инициализированное при объявлении значением Direction.LEFT.
6.	В классе Snake должен существовать публичный сеттер поля direction &mdash; setDirection(Direction), который устанавливает полю класса значение, полученное в качестве параметра.


Игра змейка (8/20)

Каждый ход змейка должна перемещаться. Ход занимает определенный промежуток времени, который ты можешь задать.

Для определения логики передвижения змейки, в классе Snake создай
метод void move(). В классе SnakeGame переопредели родительский метод onTurn(int). Всё, что должно происходить в игре на протяжении одного хода,
описывается здесь. После передвижения змейки не забудь перерисовать игровое поле.

Для установки продолжительности хода, создай переменную turnDelay. Игра будет начинаться со скоростью 300мс/ход. Установи продолжительность хода
в момент создания игры.


Требования:
1.	В классе Snake должен существовать публичный метод void move().
2.	В классе SnakeGame должен быть переопределен метод onTurn(int) родительского класса Game.
3.	В методе onTurn(int) у объекта snake должен быть вызван метод move().
4.	В методе onTurn(int) должен быть вызван метод drawScene() после вызова snake.move().
5.	В классе SnakeGame должно существовать приватное поле turnDelay типа int.
6.	В методе createGame() поле turnDelay должно быть инициализировано значением 300.
7.	В методе createGame() должен вызываться метод setTurnTimer(int). В качестве параметра передай turnDelay.


Игра змейка (9/20)


Движение змейки очень простое: в соседней с головой ячейке создается новая голова, а последний элемент (хвост) змейки удаляется.

В классе Snake реализуй метод createNewHead(), который создает новый элемент GameObject и возвращает его. Новый
элемент GameObject должен создаваться рядом с элементом, в котором на данный момент находится голова змейки (элемент с индексом 0 из snakeParts).
Новый элемент GameObject создается с той стороны, куда движется змейка (поле direction).
Пример:
- если змейка движется влево, new GameObject(headX-1, headY);
- если змейка движется вниз, new GameObject(headX, headY + 1)
Здесь headX — координата головы змеи x, headY — координата головы змеи y.

Примечание: координаты могут быть отрицательные и/или быть за границами игрового поля. Пока что это нормально, в дальнейших частях задачи исправим.

В классе Snake создай метод removeTail() и реализуй его.


Требования:
1.	В классе Snake должен существовать публичный метод GameObject createNewHead().
2.	Метод createNewHead() должен быть реализован согласно условию.
3.	В классе Snake должен существовать публичный метод void removeTail().
4.	Метод removeTail() должен удалять последний элемент из списка snakeParts.


Игра змейка (10/20)

Теперь нужно скомбинировать работу методов createNewHead() и removeTail(). Удобно сделать это в методе move().

Добавь проверку на выход змейки за пределы игрового поля. Если новая голова вышла за пределы игрового поля, установи состояние змейки в "неживая".

После передвижения змейки нужно очищать игровое поле от  уже несуществующих ее элементов. Для этого в методе drawScene() нужно не только
изменять цвет ячеек, но и устанавливать в их значении пустую строку.


Требования:
1.	В методе move() класса Snake должен вызываться метод createNewHead().
2.	В методе move() результат вызова метода createNewHead() необходимо добавить в snakeParts на позицию с индексом 0.
3.	В методе move() класса Snake после создания новой головы змеи должен вызываться метод removeTail().
4.	В методе move(), если метод createNewHead() вернул элемент, у которого координаты находятся вне игрового поля, необходимо установить полю isAlive значение false и больше ничего не делать.
5.	В классе SnakeGame в методе drawScene() необходимо заменить вызов метода setCellColor(int, int, Color) на вызов метода setCellValueEx(int, int, Color, String) с параметрами: x, y, цвет (например, Color.DARKSEAGREEN) и пустая строка.


Игра змейка (11/20)

Добавим возможность управления нашей змейкой. Для считывания клавиш переопредели метод onKeyPress(Key) родительского класса Game. В зависимости от
нажатой клавиши, установи соответствующее направление движения змейке. Учти, что змейка не может мгновенно развернуться на 180 градусов.


Требования:
1.	В классе SnakeGame должен быть переопределен метод onKeyPress(Key) родительского класса Game.
2.	Если в метод onKeyPress(Key) пришел параметр Key.LEFT, необходимо вызвать у змейки метод setDirection(Direction) c параметром Direction.LEFT.
3.	Если в метод onKeyPress(Key) пришел параметр Key.RIGHT, необходимо вызвать у змейки метод setDirection(Direction) c параметром Direction.RIGHT.
4.	Если в метод onKeyPress(Key) пришел параметр Key.UP, необходимо вызвать у змейки метод setDirection(Direction) c параметром Direction.UP.
5.	Если в метод onKeyPress(Key) пришел параметр Key.DOWN, необходимо вызвать у змейки метод setDirection(Direction) c параметром Direction.DOWN.
6.	В классе Snake метод setDirection(Direction) не должен изменять направление движения змейки, если параметр метода противоположен текущему направлению.



Игра змейка (12/20)

У нас уже есть змейка, которая умеет двигаться, и яблоко. Теперь реализуем их взаимодействие. Для начала добавь переменную яблока в
класс SnakeGame, и в момент создания игры инициализируй ее координатами (5, 5). Также прорисуй яблоко.

Перепиши метод move() класса Snake. Теперь в качестве аргумента он должен принимать яблоко, и если окажется, что змейка "съела" яблоко, состояние
яблока должно устанавливаться в "неживое", а размер змейки — увеличиваться на 1 элемент.

Требования:
1.	В классе SnakeGame должно существовать приватное поле Apple apple.
2.	В методе createGame() поле apple необходимо инициализировать новым объектом типа Apple с параметрами 5, 5 перед вызовом метода drawScene().
3.	В методе drawScene() необходимо вызвать у apple метод draw(Game) после отрисовки змеи. В качестве параметра передай в метод this.
4.	В классе Snake не должен существовать метод public void move().
5.	В классе Snake должен существовать публичный метод void move(Apple apple).
6.	В методе move(Apple), если координаты новой головы змеи совпадают с координатами яблока, необходимо установить яблоку isAlive=false и не удалять хвост змеи.
7.	В методе onTurn(int) класса SnakeGame необходимо вызвать у змеи метод move(Apple).


Игра змейка (13/20)

До этого мы устанавливали координаты яблока вручную. Необходимо создать метод для генерации новых яблок. Назовем его createNewApple().
Метод должен генерировать случайные координаты ячейки в пределах игрового поля, на которой будет появляться яблоко. Ссылку на новосозданное
яблоко присвой полю apple. Также в конце каждого хода нужно проверить, "живое" ли текущее яблоко, если нет — создать новое.
Для генерирования случайных чисел вызывай метод родительского класса getRandomNumber(int).


Требования:
1.	В классе SnakeGame должен существовать приватный метод void createNewApple().
2.	В методе createNewApple() должен два раза вызываться метод getRandomNumber(int). Первый раз &mdash; с параметром WIDTH, второй &mdash; c HEIGHT.
3.	В методе createNewApple() должен создаваться новый объект типа Apple. В качестве параметров передай результаты двух вызовов метода getRandomNumber(int).
4.	Полю apple должна присваиваться ссылка на созданный объект типа Apple.
5.	В методе createGame() не должен создаваться новый объект типа Apple.
6.	В методе createGame() должен вызываться метод createNewApple() перед методом drawScene().
7.	В методе onTurn() перед вызовом метода drawScene(), если apple.isAlive == false, необходимо вызвать метод createNewApple().


Игра змейка (14/20)

Сейчас змейка может ходить сквозь свое тело, а это не по правилам. Чтобы это исправить, нужно проверять новосозданную голову змейки на совпадение
со всеми остальными элементами её тела. Для этого в классе Snake создай метод checkCollision(GameObject). Метод checkCollision(GameObject) должен
возвращать true, если координаты переданного объекта совпадают с координатами одного из элементов тела змейки. Также в методе move(Apple) добавь
проверку на столкновения новой головы и тела. Если было столкновение, установи переменной isAlive значение false.


Требования:
1.	В классе Snake должен существовать публичный метод boolean checkCollision(GameObject).
2.	Метод checkCollision(GameObject) должен возвращать true, если координаты объекта, пришедшего параметром, совпали с координатами одного из элементов змеи (список snakeParts).
3.	Метод checkCollision(GameObject) должен возвращать false, если координаты объекта, пришедшего параметром, не совпали с координатами всех элементов змеи (список snakeParts).
4.	В методе move(Apple) должен быть вызван метод checkCollision(GameObject) с параметром &lt;новая голова&gt; перед добавлением нового сегмента змеи в список snakeParts.
5.	Если вызов метода checkCollision(GameObject) вернул true, полю isAlive необходимо установить значение false.
6.	Если вызов метода checkCollision(GameObject) вернул true, содержимое списка snakeParts не должно изменяться.


Игра змейка (15/20)

Для хранения состояния игры нам понадобится переменная isGameStopped в классе SnakeGame. Проинициализируй
её в методе createGame(). Когда игра проиграна, её нужно остановить и вывести сообщение об этом игроку.
Для этого создай метод gameOver() и добавь в него команды, которые выполняются при остановке игры (проигрыше):
- вызов метода stopTurnTimer();
- присвоение флагу isGameStopped значения true;
- вывод сообщения "GAME OVER".
Проверку состояния флага isGameStopped нужно проводить в конце каждого хода, и если игра остановлена, вызывать метод gameOver().


Требования:
1.	В классе SnakeGame должно существовать приватное поле boolean isGameStopped.
2.	В методе createGame() поле isGameStopped должно быть инициализировано значением false перед вызовом метода drawScene().
3.	В классе SnakeGame должен существовать приватный метод void gameOver().
4.	В методе gameOver() должен вызываться метод родительского класса stopTurnTimer().
5.	В методе gameOver() полю isGameStopped должно устанавливаться значение true.
6.	В методе gameOver() должен вызываться метод родительского класса showMessageDialog(Color, String, Color, int).
7.	В методе onTurn(int) должен вызываться метод gameOver() перед методом drawScene(), если змея мертвая (isAlive == false).


Игра змейка (16/20)

Игра должна останавливаться и в случае победы. Победа наступает, когда змейка увеличивается до определённого размера. Для хранения этого размера
в классе SnakeGame создай константу GOAL и инициализируй её значением 28. Для определения текущего размера змейки в классе Snake, создай
метод getLength() и реализуй его. По аналогии с методом gameOver(), создай и реализуй метод win(). Только вместо надписи "GAME OVER" он должен
выводить "YOU WIN". Проверка победы также производится в конце каждого хода.


Требования:
1.	В классе SnakeGame должно существовать приватное статическое final int поле GOAL, инициализированное при объявлении значением 28.
2.	В классе Snake должен существовать публичный метод int getLength(), который возвращает количество сегментов змеи в списке snakeParts.
3.	В классе SnakeGame должен существовать приватный метод void win().
4.	В методе win() должен вызываться метод stopTurnTimer().
5.	В методе win() полю isGameStopped должно устанавливаться значение true.
6.	В методе win() должен вызываться метод showMessageDialog(Color, String, Color, int).
7.	В методе onTurn(int) должен вызываться метод win() перед методом drawScene(), если значение, возвращенное методом getLength(), больше чем GOAL.


Игра змейка (17/20)

На данном этапе у нас есть один баг — яблоко может сгенерироваться на теле змейки. Для устранения бага, воспользуемся созданным
методом checkCollision(GameObject). Метод createNewApple() должен создавать новое яблоко (с новыми координатами) в цикле до тех пор,
пока результат вызова метода checkCollision(GameObject) не будет false.

Также давай реализуем рестарт игры нажатием клавиши SPACE (пробел). Игра запускается заново только если она остановлена.


Требования:
1.	Метод createNewApple() должен вызывать метод checkCollision(GameObject), передавая объект класса Apple в качестве параметра.
2.	Метод createNewApple() должен вызывать метод checkCollision(GameObject) до тех пор, пока координаты apple и любого из сегментов змеи совпадают.
3.	Метод onKeyPress(Key) должен вызывать метод createGame(), если параметр метода &mdash; клавиша SPACE, и игра была остановлена (isGameStopped == true).


Игра змейка (18/20)

Давай поправим управление. Значения поля direction могут меняться только на валидные в данный момент: LEFT, RIGHT, UP, DOWN.


Требования:
1.	Метод setDirection(Direction) класса Snake не должен ничего делать, если значение поля direction равно LEFT, и сегменты змейки из snakeParts с индексами 0 и 1 имеют одинаковое значение координаты x.
2.	Метод setDirection(Direction) класса Snake не должен ничего делать, если значение поля direction равно RIGHT, и сегменты змейки из snakeParts с индексами 0 и 1 имеют одинаковое значение координаты x.
3.	Метод setDirection(Direction) класса Snake не должен ничего делать, если значение поля direction равно UP, и сегменты змейки из snakeParts с индексами 0 и 1 имеют одинаковое значение координаты y.
4.	Метод setDirection(Direction) класса Snake не должен ничего делать, если значение поля direction равно DOWN, и сегменты змейки из snakeParts с индексами 0 и 1 имеют одинаковое значение координаты y.


Игра змейка (19/20)

Остался последний штрих — ввести подсчёт и отображение набранных очков. Для подсчёта создай переменную score и присвой ей значение 0 на момент
создания новой игры. Для отображения значения score на экране используй метод setScore(int). Вызывай его после каждого изменения score.
Значение score должно увеличиваться на 5 после каждого съеденного яблока.

Также после каждого съеденного яблока должна увеличиваться скорость игры, то есть уменьшаться на 10 значение turnDelay (временной промежуток на ход).
После каждого изменения turnDelay должен вызываться метод setTurnTimer(int).


Требования:
1.	В классе SnakeGame должно существовать приватное поле int score.
2.	Поле score должно быть инициализировано в методе createGame() значением 0.
3.	Метод createGame() должен вызывать метод setScore(int) с параметром score.
4.	Метод onTurn(int) должен увеличивать значение поля score на 5, если яблоко &quot;неживое&quot;.
5.	Метод onTurn(int) должен вызвать метод setScore(int) с параметром score, если яблоко &quot;неживое&quot;.
6.	Метод onTurn(int) должен уменьшить значение поля turnDelay на 10, если яблоко &quot;неживое&quot;.
7.	Метод onTurn(int) должен вызвать метод setTurnTimer(int) с параметром turnDelay, если яблоко &quot;неживое&quot;.


Игра змейка (20/20)

Наши поздравления: игра написана! Предлагаем запустить ее и посмотреть, что получилось.

Если есть время и вдохновение, можешь улучшить игру, добавив некоторые "фичи" от себя.

Например:

- сделать возможным выбор размера игрового поля перед началом игры;
- усложнить или упростить игру, изменив формулу ускорения ходов;
- поменять систему начисления очков, зависящую от скорости игры;
- добавить змейке возможность проходить сквозь стены;
- кроме яблок, генерировать и другие фрукты, которые будут давать бонусы (например, неуязвимость к следующему удару);
- в случае победы — переход на следующие уровни;
- и всё, что тебе позволит фантазия :)

Готовую игру ты можешь опубликовать на JavaRush. Но перед этим нужно отправить свое решение на проверку, чтобы была доступна кнопка публикации. Игра будет доступна в разделе "Игры" всем пользователям.
А еще ты можешь поделиться ею с друзьями в соцсетях. Будет здорово, если они сыграют в твою версию "Змейки", не так ли?

После публикации, в комментариях напиши краткую инструкцию (какие действия доступны, какие клавиши или кнопки нужно использовать для игры), а также особенности твоей реализации.


Требования:
1. Запусти игру и поиграй.
